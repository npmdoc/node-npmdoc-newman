<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/postmanlabs/newman"

    >newman (v3.5.2)</a>
</h1>
<h4>Command-line companion utility for Postman</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.newman">module newman</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.run">
            function <span class="apidocSignatureSpan">newman.</span>run
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.summary">
            function <span class="apidocSignatureSpan">newman.</span>summary
            <span class="apidocSignatureSpan">(emitter, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.version">
            function <span class="apidocSignatureSpan">newman.</span>version
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newman.</span>cli_utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newman.</span>rc_file</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newman.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newman.cli_utils">module newman.cli_utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.cli_utils.dimension">
            function <span class="apidocSignatureSpan">newman.cli_utils.</span>dimension
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.cli_utils.inspector">
            function <span class="apidocSignatureSpan">newman.cli_utils.</span>inspector
            <span class="apidocSignatureSpan">(runOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.cli_utils.noTTY">
            function <span class="apidocSignatureSpan">newman.cli_utils.</span>noTTY
            <span class="apidocSignatureSpan">(color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.cli_utils.padLeft">
            function <span class="apidocSignatureSpan">newman.cli_utils.</span>padLeft
            <span class="apidocSignatureSpan">(nr, n, str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.cli_utils.symbols">
            function <span class="apidocSignatureSpan">newman.cli_utils.</span>symbols
            <span class="apidocSignatureSpan">(disableUnicode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.cli_utils.wrapper">
            function <span class="apidocSignatureSpan">newman.cli_utils.</span>wrapper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newman.cli_utils.</span>cliTableTemplateFallback</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newman.cli_utils.</span>cliTableTemplate_Blank</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newman.rc_file">module newman.rc_file</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.rc_file.load">
            function <span class="apidocSignatureSpan">newman.rc_file.</span>load
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newman.summary">module newman.summary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.summary.summary">
            function <span class="apidocSignatureSpan">newman.</span>summary
            <span class="apidocSignatureSpan">(emitter, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.summary.attachFailureTrackers">
            function <span class="apidocSignatureSpan">newman.summary.</span>attachFailureTrackers
            <span class="apidocSignatureSpan">(summary, emitter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.summary.attachReportingTrackers">
            function <span class="apidocSignatureSpan">newman.summary.</span>attachReportingTrackers
            <span class="apidocSignatureSpan">(summary, emitter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.summary.attachRequestTracker">
            function <span class="apidocSignatureSpan">newman.summary.</span>attachRequestTracker
            <span class="apidocSignatureSpan">(summary, emitter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.summary.attachStatisticTrackers">
            function <span class="apidocSignatureSpan">newman.summary.</span>attachStatisticTrackers
            <span class="apidocSignatureSpan">(summary, emitter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.summary.attachTimingTrackers">
            function <span class="apidocSignatureSpan">newman.summary.</span>attachTimingTrackers
            <span class="apidocSignatureSpan">(summary, emitter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newman.util">module newman.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.util.fetch">
            function <span class="apidocSignatureSpan">newman.util.</span>fetch
            <span class="apidocSignatureSpan">(location, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.util.fetchJson">
            function <span class="apidocSignatureSpan">newman.util.</span>fetchJson
            <span class="apidocSignatureSpan">(location, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.util.filesize">
            function <span class="apidocSignatureSpan">newman.util.</span>filesize
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.util.getFullName">
            function <span class="apidocSignatureSpan">newman.util.</span>getFullName
            <span class="apidocSignatureSpan">(item, separator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newman.util.prettyms">
            function <span class="apidocSignatureSpan">newman.util.</span>prettyms
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">newman.util.</span>userAgent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">newman.util.</span>version</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newman" id="apidoc.module.newman">module newman</a></h1>


    <h2>
        <a href="#apidoc.element.newman.run" id="apidoc.element.newman.run">
        function <span class="apidocSignatureSpan">newman.</span>run
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (options, callback) {
    // validate all options. it is to be noted that `options` parameter is option and is polymorphic
    (!callback &#x26;&#x26; _.isFunction(options)) &#x26;&#x26; (
        (callback = options),
        (options = {})
    );
    !_.isFunction(callback) &#x26;&#x26; (callback = _.noop);

    var emitter = new EventEmitter(), // @todo: create a new inherited constructor
        runner = new runtime.Runner();

    // get the configuration from various sources
    getOptions(options, function (err, options) {
        if (err) {
            return callback(err);
        }

        // ensure that the collection option is present before starting a run
        if (!_.isObject(options.collection)) {
            return callback(new Error(&#x27;newman: expecting a collection to run&#x27;));
        }

        // store summary object and other relevant information inside the emitter
        emitter.summary = new RunSummary(emitter, options);

        // to store the exported content from reporters
        emitter.exports = [];

        // now start the run!
        runner.run(options.collection, {
            stopOnFailure: options.bail, // LOL, you just got trolled ¯\_(ツ)_/¯
            abortOnFailure: options.abortOnFailure, // used in integration tests, to be considered for a future release
            iterationCount: options.iterationCount,
            environment: options.environment,
            globals: options.globals,
            entrypoint: options.folder,
            data: options.iterationData,
            delay: {
                item: options.delayRequest
            },
            // todo: add support for more types of timeouts, currently only request is supported
            timeout: options.timeoutRequest ? { request: options.timeoutRequest } : undefined,
            fileResolver: fs,
            requester: {
                cookieJar: request.jar(),
                followRedirects: _.has(options, &#x27;ignoreRedirects&#x27;) ? !options.ignoreRedirects : undefined,
                strictSSL: _.has(options, &#x27;insecure&#x27;) ? !options.insecure : undefined
            },
            certificates: options.sslClientCert &#x26;&#x26; new sdk.CertificateList({}, [{
                name: &#x27;client-cert&#x27;,
                matches: [sdk.UrlMatchPattern.MATCH_ALL_URLS],
                key: { src: options.sslClientKey },
                cert: { src: options.sslClientCert },
                passphrase: options.sslClientPassphrase
            }])
        }, function (err, run) {
            var callbacks = {},
                // ensure that the reporter option type polymorphism is handled
                reporters = _.isString(options.reporters) ? [options.reporters] : options.reporters;

            // emit events for all the callbacks triggered by the runtime
            _.forEach(runtimeEvents, function (definition, eventName) {
                // intercept each runtime.* callback and expose a global object based event
                callbacks[eventName] = function (err, cursor) {
                    var args = arguments,
                        obj = { cursor: cursor };

                    // convert the arguments into an object by taking the key name reference from the definition
                    // object
                    _.forEach(definition, function (key, index) {
                        obj[key] = args[index + 2]; // first two are err, cursor
                    });

                    args = [eventName, err, obj];
                    emitter.emit.apply(emitter, args); // eslint-disable-line prefer-spread
                };
            });

            // add non generic callback handling
            _.assignIn(callbacks, {

<span class="apidocCodeCommentSpan">                /**
                 * Bubbles up console messages.
                 *
                 * @param {Object} cursor - The run cursor instance.
                 * @param {String} level - The level of console logging [error, silent, etc].
                 * @returns {*}
                 */
</span>                console: function (cursor, level) {
                    emitter.emit(&#x27;console&#x27;, null, { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Newman can be easily used within your JavaScript projects as a NodeJS module. The entire set of Newman CLI functionality is available
 for programmatic use as well. The following example runs a collection by reading a JSON collection file stored on disk.

```javascript
var newman = require(&#x27;newman&#x27;); // require newman in your project

// call newman.run to pass `options` object and wait for callback
newman.<span class="apidocCodeKeywordSpan">run</span>({
    collection: require(&#x27;./sample-collection.json&#x27;),
    reporters: &#x27;cli&#x27;
}, function (err) {
	if (err) { throw err; }
    console.log(&#x27;collection run complete!&#x27;);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.summary" id="apidoc.element.newman.summary">
        function <span class="apidocSignatureSpan">newman.</span>summary
        <span class="apidocSignatureSpan">(emitter, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RunSummary(emitter, options) {
    // keep a copy of this instance since, we need to refer to this from various events
    var summary = this;

    // and store the trackers and failures in the summary object itself
    _.assign(summary,<span class="apidocCodeCommentSpan"> /** @lends RunSummary.prototype */ {
        /**
         * The collection that is being executed.
         *
         * @type {Collection}
         */
</span>        collection: _.get(options, &#x27;collection&#x27;),

        /**
         * The environment that is being used during the run
         * @type {VariableScope}
         *
         */
        environment: _.get(options, &#x27;environment&#x27;),

        /**
         * Global variables being used during the run
         * @type {VariableScope}
         */
        globals: _.get(options, &#x27;globals&#x27;),

        /**
         * Holds information related to the run.
         */
        run: {
            /**
             * Holds the statistics of the run. Each property in it is the item being tracked and has three numeric
             * properties - total, failed, pending
             *
             * @type {Object.&#x3c;Object&#x3e;}
             */
            stats: {
                iterations: {},
                items: {},
                scripts: {},
                prerequests: {},
                requests: {},
                tests: {},
                assertions: {},
                testScripts: {},
                prerequestScripts: {}
            },

            /**
             * Stores all generic timing information
             *
             * @type {Object}
             */
            timings: {
                /**
                 * The average response time of the run
                 *
                 * @type {number}
                 */
                responseAverage: 0
            },

            /**
             * Stores detailed information about the order of execution, request, response and assertions
             *
             * @type {Array&#x3c;Object&#x3e;}
             */
            executions: [],

            /**
             * Stores information on data transfer made during the collection
             *
             * @type {Object}
             */
            transfers: {
                /**
                 * The total data received as response to every request
                 *
                 * @type {number}
                 */
                responseTotal: 0
            },

            /**
             * An array of all errors encountered during the run
             *
             * @type {Array.&#x3c;Error&#x3e;}
             */
            failures: [],

            /**
             * This stores any fatal error during the run that caused the run to abort prematurely.
             *
             * @type {Error}
             */
            error: null
        }
    });

    // track run timings (start and end)
    RunSummary.attachTimingTrackers(this, emitter);

    // accumulate statistics on all event
    // for all types of events track the counters for the event and its corresponding &#x22;before&#x22; counterpart
    RunSummary.attachStatisticTrackers(this, emitter);

    // accumulate statistics on requests - such as size and time
    RunSummary.attachRequestTracker(this, emitter);

    // accumulate errors (failures) from all events
    RunSummary.attachFailureTrackers(this, emitter);

    // accumulate all execution specific data in collection
    RunSummary.attachReportingTrackers(this, emitter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.version" id="apidoc.element.newman.version">
        function <span class="apidocSignatureSpan">newman.</span>version
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">version = function () {
    console.info(version);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newman.cli_utils" id="apidoc.module.newman.cli_utils">module newman.cli_utils</a></h1>


    <h2>
        <a href="#apidoc.element.newman.cli_utils.dimension" id="apidoc.element.newman.cli_utils.dimension">
        function <span class="apidocSignatureSpan">newman.cli_utils.</span>dimension
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dimension = function () {
    var tty,
        width,
        height;

    try { tty = require(&#x27;tty&#x27;); }
    catch (e) { tty = null; }

    if (tty &#x26;&#x26; tty.isatty(1) &#x26;&#x26; tty.isatty(2)) {
        if (process.stdout.getWindowSize) {
            width = process.stdout.getWindowSize(1)[0];
            height = process.stdout.getWindowSize(1)[1];
        }
        else if (tty.getWindowSize) {
            width = tty.getWindowSize()[1];
            height = tty.getWindowSize()[0];
        }
        else if (process.stdout.columns &#x26;&#x26; process.stdout.rows) {
            height = process.stdout.rows;
            width = process.stdout.columns;
        }
    }

    return {
        exists: !(Boolean(process.env.CI) || !process.stdout.isTTY),
        width: width,
        height: height
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    /**
     * A CLI utility helper method that generates a color inspector function for CLI reports.
     *
     * @param {Object} runOptions - The set of run options acquired via the runner.
     * @return {Function} - A function to perform utils.inspect, given a sample item, under pre-existing options.
     */
    inspector: function (runOptions) {
var dimension = cliUtils.<span class="apidocCodeKeywordSpan">dimension</span>(),
    options = {
        colors: !(runOptions.noColor || cliUtils.noTTY(runOptions.color)),
        // note that similar dimension calculation is in utils.wrapper
        breakLength: ((dimension.exists &#x26;&#x26; (dimension.width &#x3e; 20)) ? dimension.width : 60) - 16
    };

return function (item) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.cli_utils.inspector" id="apidoc.element.newman.cli_utils.inspector">
        function <span class="apidocSignatureSpan">newman.cli_utils.</span>inspector
        <span class="apidocSignatureSpan">(runOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspector = function (runOptions) {
    var dimension = cliUtils.dimension(),
        options = {
            colors: !(runOptions.noColor || cliUtils.noTTY(runOptions.color)),
            // note that similar dimension calculation is in utils.wrapper
            breakLength: ((dimension.exists &#x26;&#x26; (dimension.width &#x3e; 20)) ? dimension.width : 60) - 16
        };

    return function (item) {
        return inspect(item, options);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.cli_utils.noTTY" id="apidoc.element.newman.cli_utils.noTTY">
        function <span class="apidocSignatureSpan">newman.cli_utils.</span>noTTY
        <span class="apidocSignatureSpan">(color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noTTY = function (color) {
    return !color &#x26;&#x26; (Boolean(process.env.CI) || !process.stdout.isTTY);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     *
     * @param {Object} runOptions - The set of run options acquired via the runner.
     * @return {Function} - A function to perform utils.inspect, given a sample item, under pre-existing options.
     */
    inspector: function (runOptions) {
var dimension = cliUtils.dimension(),
    options = {
        colors: !(runOptions.noColor || cliUtils.<span class="apidocCodeKeywordSpan">noTTY</span>(runOptions.color)),
        // note that similar dimension calculation is in utils.wrapper
        breakLength: ((dimension.exists &#x26;&#x26; (dimension.width &#x3e; 20)) ? dimension.width : 60) - 16
    };

return function (item) {
    return inspect(item, options);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.cli_utils.padLeft" id="apidoc.element.newman.cli_utils.padLeft">
        function <span class="apidocSignatureSpan">newman.cli_utils.</span>padLeft
        <span class="apidocSignatureSpan">(nr, n, str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">padLeft = function (nr, n, str) {
    return Array(n - String(nr).length + 1).join(str || &#x27;0&#x27;) + nr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.cli_utils.symbols" id="apidoc.element.newman.cli_utils.symbols">
        function <span class="apidocSignatureSpan">newman.cli_utils.</span>symbols
        <span class="apidocSignatureSpan">(disableUnicode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symbols = function (disableUnicode) {
    if (disableUnicode) {
        return subsets.plainText;
    }
    if (IS_WINDOWS) { // modify symbols for windows platforms
        return subsets.encoded;
    }

    return subsets.regular;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.cli_utils.wrapper" id="apidoc.element.newman.cli_utils.wrapper">
        function <span class="apidocSignatureSpan">newman.cli_utils.</span>wrapper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrapper = function () {
    var dimension = cliUtils.dimension(),
        // note that similar dimension calculation is in utils.wrapper
        width = ((dimension.exists &#x26;&#x26; (dimension.width &#x3e; 20)) ? dimension.width : 60) - 6;

    return function (text, indent) {
        return wrap(text, {
            indent: indent,
            width: width,
            cut: true
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newman.rc_file" id="apidoc.module.newman.rc_file">module newman.rc_file</a></h1>


    <h2>
        <a href="#apidoc.element.newman.rc_file.load" id="apidoc.element.newman.rc_file.load">
        function <span class="apidocSignatureSpan">newman.rc_file.</span>load
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(callback) =&#x3e; {
    var iswin = (/^win/).test(process.platform),
        home = iswin ? process.env.USERPROFILE : process.env.HOME,

        configFiles = [];

    configFiles.push(join(process.cwd(), &#x27;.&#x27; + FILE_NAME));
    home &#x26;&#x26; configFiles.push(join(home, &#x27;.&#x27; + POSTMAN_CONFIG_DIR, FILE_NAME));
    !iswin &#x26;&#x26; configFiles.push(join(&#x27;/etc&#x27;, POSTMAN_CONFIG_DIR, FILE_NAME));

    async.mapSeries(configFiles, (path, cb) =&#x3e; {
        fs.readFile(path, (err, data) =&#x3e; {
            if (err) {
                return cb(null, {}); // err masked to avoid overpopulating terminal with missing .newmanrc messages
            }
            data &#x26;&#x26; data.toString &#x26;&#x26; (data = data.toString());
            try {
                return cb(null, parseJson(data));
            }
            catch (e) {
                return cb(_.set(e, &#x27;help&#x27;, `The file at ${path} contains invalid data.`));
            }
        });
    }, (err, files) =&#x3e; {
        if (err) {
            return callback(err);
        }

        return callback(null, _.merge.apply(this, files));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newman.summary" id="apidoc.module.newman.summary">module newman.summary</a></h1>


    <h2>
        <a href="#apidoc.element.newman.summary.summary" id="apidoc.element.newman.summary.summary">
        function <span class="apidocSignatureSpan">newman.</span>summary
        <span class="apidocSignatureSpan">(emitter, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RunSummary(emitter, options) {
    // keep a copy of this instance since, we need to refer to this from various events
    var summary = this;

    // and store the trackers and failures in the summary object itself
    _.assign(summary,<span class="apidocCodeCommentSpan"> /** @lends RunSummary.prototype */ {
        /**
         * The collection that is being executed.
         *
         * @type {Collection}
         */
</span>        collection: _.get(options, &#x27;collection&#x27;),

        /**
         * The environment that is being used during the run
         * @type {VariableScope}
         *
         */
        environment: _.get(options, &#x27;environment&#x27;),

        /**
         * Global variables being used during the run
         * @type {VariableScope}
         */
        globals: _.get(options, &#x27;globals&#x27;),

        /**
         * Holds information related to the run.
         */
        run: {
            /**
             * Holds the statistics of the run. Each property in it is the item being tracked and has three numeric
             * properties - total, failed, pending
             *
             * @type {Object.&#x3c;Object&#x3e;}
             */
            stats: {
                iterations: {},
                items: {},
                scripts: {},
                prerequests: {},
                requests: {},
                tests: {},
                assertions: {},
                testScripts: {},
                prerequestScripts: {}
            },

            /**
             * Stores all generic timing information
             *
             * @type {Object}
             */
            timings: {
                /**
                 * The average response time of the run
                 *
                 * @type {number}
                 */
                responseAverage: 0
            },

            /**
             * Stores detailed information about the order of execution, request, response and assertions
             *
             * @type {Array&#x3c;Object&#x3e;}
             */
            executions: [],

            /**
             * Stores information on data transfer made during the collection
             *
             * @type {Object}
             */
            transfers: {
                /**
                 * The total data received as response to every request
                 *
                 * @type {number}
                 */
                responseTotal: 0
            },

            /**
             * An array of all errors encountered during the run
             *
             * @type {Array.&#x3c;Error&#x3e;}
             */
            failures: [],

            /**
             * This stores any fatal error during the run that caused the run to abort prematurely.
             *
             * @type {Error}
             */
            error: null
        }
    });

    // track run timings (start and end)
    RunSummary.attachTimingTrackers(this, emitter);

    // accumulate statistics on all event
    // for all types of events track the counters for the event and its corresponding &#x22;before&#x22; counterpart
    RunSummary.attachStatisticTrackers(this, emitter);

    // accumulate statistics on requests - such as size and time
    RunSummary.attachRequestTracker(this, emitter);

    // accumulate errors (failures) from all events
    RunSummary.attachFailureTrackers(this, emitter);

    // accumulate all execution specific data in collection
    RunSummary.attachReportingTrackers(this, emitter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.summary.attachFailureTrackers" id="apidoc.element.newman.summary.attachFailureTrackers">
        function <span class="apidocSignatureSpan">newman.summary.</span>attachFailureTrackers
        <span class="apidocSignatureSpan">(summary, emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachFailureTrackers = function (summary, emitter) {
    var eventsToTrack = [&#x27;beforeIteration&#x27;, &#x27;iteration&#x27;, &#x27;beforeItem&#x27;, &#x27;item&#x27;, &#x27;beforeScript&#x27;, &#x27;script&#x27;,
        &#x27;beforePrerequest&#x27;, &#x27;prerequest&#x27;, &#x27;beforeRequest&#x27;, &#x27;request&#x27;, &#x27;beforeTest&#x27;, &#x27;test&#x27;, &#x27;beforeAssertion&#x27;,
        &#x27;assertion&#x27;];

    // accumulate failures of all events
    // NOTE that surrogate events (which throw duplicate arguments) are not recorded
    _.forEach(eventsToTrack, function (event) {
        // push failures sent from &#x22;before&#x22; events
        emitter.on(event, function (err, o) {
            if (!err) { return; }

            var item = o &#x26;&#x26; o.item,
                source = event;

            // in case of user script error, point to the line and column of the script and its type
            if (event === &#x27;script&#x27;) {
                o.event &#x26;&#x26; (source = o.event.listen + &#x27;-script&#x27;);
                if (err.stacktrace &#x26;&#x26; err.stacktrace[0] &#x26;&#x26; err.stacktrace[0].lineNumber) {
                    source += (&#x27;:&#x27; + (err.stacktrace[0].lineNumber - 2));
                    err.stacktrace[0].columnNumber &#x26;&#x26; (source += (&#x27;:&#x27; + err.stacktrace[0].columnNumber));
                }
            }
            // assertion errors need to know which assertion in the test was this
            else if (event === &#x27;assertion&#x27;) {
                _.has(err, &#x27;index&#x27;) &#x26;&#x26; (source += (&#x27;:&#x27; + (err.index + 1)));
                source += &#x27; in test-script&#x27;;
            }

            // if this is a plain error, convert it to serialised error
            if (err.stack &#x26;&#x26; !err.stacktrace) {
                err = new SerialiseError(err, true);
            }

            summary.run.failures.push({
                error: err,
                at: source,
                source: item || undefined,
                parent: item &#x26;&#x26; item.__parent &#x26;&#x26; item.__parent.__parent || undefined,
                cursor: o.cursor || {}
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// for all types of events track the counters for the event and its corresponding &#x22;before&#x22; counterpart
RunSummary.attachStatisticTrackers(this, emitter);

// accumulate statistics on requests - such as size and time
RunSummary.attachRequestTracker(this, emitter);

// accumulate errors (failures) from all events
RunSummary.<span class="apidocCodeKeywordSpan">attachFailureTrackers</span>(this, emitter);

// accumulate all execution specific data in collection
RunSummary.attachReportingTrackers(this, emitter);
};

_.assign(RunSummary, {
attachReportingTrackers: function (summary, emitter) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.summary.attachReportingTrackers" id="apidoc.element.newman.summary.attachReportingTrackers">
        function <span class="apidocSignatureSpan">newman.summary.</span>attachReportingTrackers
        <span class="apidocSignatureSpan">(summary, emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachReportingTrackers = function (summary, emitter) {
    var cache = {},
        executions = summary.run.executions;

    emitter.on(&#x27;beforeItem&#x27;, function (err, o) {
        if (!_.get(o, &#x27;cursor.ref&#x27;)) { return; }

        cache[o.cursor.ref] = _.assignIn(cache[o.cursor.ref] || {}, {
            cursor: o.cursor,
            item: o.item
        });
    });

    // save all responses in executions array
    emitter.on(&#x27;request&#x27;, function (err, o) {
        if (!_.get(o, &#x27;cursor.ref&#x27;)) { return; }

        var execution = cache[o.cursor.ref] = (cache[o.cursor.ref] || {});

        executions.push(_.assignIn(execution, {
            cursor: o.cursor,
            request: o.request,
            response: _.omit(o.response, &#x27;stream&#x27;),
            id: _.get(o, &#x27;item.id&#x27;)
        }, err &#x26;&#x26; {
            requestError: err || undefined
        }));
    });

    // save all script execution errors in each execution
    emitter.on(&#x27;script&#x27;, function (err, o) {
        if (!_.get(o, &#x27;cursor.ref&#x27;)) { return; }

        var execution = cache[o.cursor.ref] = (cache[o.cursor.ref] || {}),
            eventName = o &#x26;&#x26; o.event &#x26;&#x26; (o.event.listen + &#x27;Script&#x27;);

        // store the script error corresponding to the script event name
        err &#x26;&#x26; (execution &#x26;&#x26; eventName) &#x26;&#x26; (execution[eventName] || (execution[eventName] = [])).push({
            error: err
        });
    });

    // save all assertions in each execution
    emitter.on(&#x27;assertion&#x27;, function (err, o) {
        if (!_.get(o, &#x27;cursor.ref&#x27;)) { return; }

        var execution = cache[o.cursor.ref] = (cache[o.cursor.ref] || {});
        if (!execution) { return; }

        (execution.assertions || (execution.assertions = [])).push({
            assertion: o.assertion,
            error: err || undefined
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// accumulate statistics on requests - such as size and time
RunSummary.attachRequestTracker(this, emitter);

// accumulate errors (failures) from all events
RunSummary.attachFailureTrackers(this, emitter);

// accumulate all execution specific data in collection
RunSummary.<span class="apidocCodeKeywordSpan">attachReportingTrackers</span>(this, emitter);
};

_.assign(RunSummary, {
attachReportingTrackers: function (summary, emitter) {
    var cache = {},
        executions = summary.run.executions;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.summary.attachRequestTracker" id="apidoc.element.newman.summary.attachRequestTracker">
        function <span class="apidocSignatureSpan">newman.summary.</span>attachRequestTracker
        <span class="apidocSignatureSpan">(summary, emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachRequestTracker = function (summary, emitter) {
    // accumulate statistics on requests
    emitter.on(&#x27;request&#x27;, function (err, o) {
        if (err || !(o &#x26;&#x26; o.response)) { return; }

        var size = _.isFunction(o.response.size) &#x26;&#x26; o.response.size(),
            time = o.response.responseTime,

            requestCount = summary.run.stats.requests.total;

        // compute the response size total
        size &#x26;&#x26; (summary.run.transfers.responseTotal += (size.body || 0 + size.headers || 0));

        // compute average response time
        time &#x26;&#x26; (summary.run.timings.responseAverage =
            ((summary.run.timings.responseAverage * (requestCount - 1) + time) / requestCount));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    RunSummary.attachTimingTrackers(this, emitter);

    // accumulate statistics on all event
    // for all types of events track the counters for the event and its corresponding &#x22;before&#x22; counterpart
    RunSummary.attachStatisticTrackers(this, emitter);

    // accumulate statistics on requests - such as size and time
    RunSummary.<span class="apidocCodeKeywordSpan">attachRequestTracker</span>(this, emitter);

    // accumulate errors (failures) from all events
    RunSummary.attachFailureTrackers(this, emitter);

    // accumulate all execution specific data in collection
    RunSummary.attachReportingTrackers(this, emitter);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.summary.attachStatisticTrackers" id="apidoc.element.newman.summary.attachStatisticTrackers">
        function <span class="apidocSignatureSpan">newman.summary.</span>attachStatisticTrackers
        <span class="apidocSignatureSpan">(summary, emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachStatisticTrackers = function (summary, emitter) {
    // accumulate statistics on all event
    // for all types of events track the counters for the event and its corresponding &#x22;before&#x22; counterpart
    _.forEach(summary.run.stats, function (tracker, name) {
        // the actual event names are singular than their plural trackers, so we make the name singular
        name = name.slice(0, -1); // remove last character

        // populate initial values of trackers
        _.assign(tracker, { total: 0, pending: 0, failed: 0 });

        // Set up common listeners for a set of events, which tracks how many times they were executed and records
        // the ones which had an error passed as first argument
        emitter.on(_.camelCase(&#x27;before-&#x27; + name), function () {
            tracker.pending += 1;
        });

        emitter.on(name, function (err) {
            // check pending so that, it does not negate for items that do not have a `before` counterpart
            tracker.pending &#x26;&#x26; (tracker.pending -= 1);
            err &#x26;&#x26; (tracker.failed += 1);
            tracker.total += 1;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// track run timings (start and end)
RunSummary.attachTimingTrackers(this, emitter);

// accumulate statistics on all event
// for all types of events track the counters for the event and its corresponding &#x22;before&#x22; counterpart
RunSummary.<span class="apidocCodeKeywordSpan">attachStatisticTrackers</span>(this, emitter);

// accumulate statistics on requests - such as size and time
RunSummary.attachRequestTracker(this, emitter);

// accumulate errors (failures) from all events
RunSummary.attachFailureTrackers(this, emitter);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.summary.attachTimingTrackers" id="apidoc.element.newman.summary.attachTimingTrackers">
        function <span class="apidocSignatureSpan">newman.summary.</span>attachTimingTrackers
        <span class="apidocSignatureSpan">(summary, emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTimingTrackers = function (summary, emitter) {
    // mark the point when the run started
    // also mark the point when run completed and also store error if needed
    emitter.on(&#x27;start&#x27;, function () { summary.run.timings.started = Date.now(); });
    emitter.on(&#x27;beforeDone&#x27;, function () {
        summary.run.timings.completed = Date.now();
    });
    emitter.on(&#x27;done&#x27;, function (err) {
        err &#x26;&#x26; (summary.error = err);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         * @type {Error}
         */
        error: null
    }
});

// track run timings (start and end)
RunSummary.<span class="apidocCodeKeywordSpan">attachTimingTrackers</span>(this, emitter);

// accumulate statistics on all event
// for all types of events track the counters for the event and its corresponding &#x22;before&#x22; counterpart
RunSummary.attachStatisticTrackers(this, emitter);

// accumulate statistics on requests - such as size and time
RunSummary.attachRequestTracker(this, emitter);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newman.util" id="apidoc.module.newman.util">module newman.util</a></h1>


    <h2>
        <a href="#apidoc.element.newman.util.fetch" id="apidoc.element.newman.util.fetch">
        function <span class="apidocSignatureSpan">newman.util.</span>fetch
        <span class="apidocSignatureSpan">(location, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (location, options, callback) {
    !callback &#x26;&#x26; _.isFunction(options) &#x26;&#x26; (callback = options, options = {});
    return (/^https?:\/\/.*/).test(location) ?
        // Load from URL
        request.get({ url: location }, (err, response, body) =&#x3e; {
            if (err) {
                return callback(err);
            }
            return callback(null, body);
        }) :
        fs.readFile(location, function (err, value) {
            if (err) {
                return callback(err);
            }
            return callback(null, value.toString());
        });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         * the array of iteration data objects.
         * @param {Function} callback - The function invoked to indicate the end of the iteration data loading routine.
         * @returns {*}
         */
        iterationData: function (location, callback) {
            if (_.isArray(location)) { return callback(null, location); }

            util.<span class="apidocCodeKeywordSpan">fetch</span>(location, function (err, data) {
if (err) {
    return callback(err);
}

// Try loading as a JSON, fallback to CSV. @todo: switch to file extension based loading.
async.waterfall([
    (cb) =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.util.fetchJson" id="apidoc.element.newman.util.fetchJson">
        function <span class="apidocSignatureSpan">newman.util.</span>fetchJson
        <span class="apidocSignatureSpan">(location, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchJson = function (location, options, callback) {
    !callback &#x26;&#x26; _.isFunction(options) &#x26;&#x26; (callback = options, options = {});
    return (/^https?:\/\/.*/).test(location) ?
        // Load from URL
        request.get({
            url: location,
            json: true,
            headers: { &#x27;User-Agent&#x27;: USER_AGENT_VALUE }
        }, (err, response, body) =&#x3e; {
            if (err) {
                return callback(_.set(err, &#x27;help&#x27;, `unable to fetch data from url &#x22;${location}&#x22;`));
            }

            try {
                _.isString(body) &#x26;&#x26; (body = parseJson(body));
            }
            catch (e) {
                return callback(_.set(e, &#x27;help&#x27;, `the url &#x22;${location}&#x22; did not provide valid JSON data`));
            }

            return callback(null, body);
        }) :
        fs.readFile(location, function (err, value) {
            if (err) {
                return callback(_.set(err, &#x27;help&#x27;, `unable to read data from file &#x22;${location}&#x22;`));
            }

            try {
                value = parseJson(value.toString());
            }
            catch (e) {
                return callback(_.set(e, &#x27;help&#x27;, `the file at ${location} does not contain valid JSON data`));
            }

            return callback(null, value);
        });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {String} type - The type of data to load.
 * @param {String} location - The location to load from (file path or URL).
 * @param {function} cb - The callback function whose invocation marks the end of the external load routine.
 * @returns {*}
 */
externalLoader = function (type, location, cb) {
    return _.isString(location) ? util.<span class="apidocCodeKeywordSpan">fetchJson</span>(location, function (err, data) {
        if (err) {
            return cb(err);
        }
        return cb(null, extractModel(data, type));
    }) : cb(null, extractModel(location, type));
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.util.filesize" id="apidoc.element.newman.util.filesize">
        function <span class="apidocSignatureSpan">newman.util.</span>filesize
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filesize = function (bytes) {
    return filesize(bytes || 0, FILESIZE_OPTIONS);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.util.getFullName" id="apidoc.element.newman.util.getFullName">
        function <span class="apidocSignatureSpan">newman.util.</span>getFullName
        <span class="apidocSignatureSpan">(item, separator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFullName = function (item, separator) {
    if (_.isEmpty(item) || !_.isFunction(item.parent) || !_.isFunction(item.forEachParent)) { return; }

    var chain = [];
    item.forEachParent(function (parent) { chain.unshift(parent.name || parent.id); });

    item.parent() &#x26;&#x26; chain.push(item.name); // Add the current item only if it is not the collection instance
    return chain.join(_.isString(separator) ? separator : SEP);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newman.util.prettyms" id="apidoc.element.newman.util.prettyms">
        function <span class="apidocSignatureSpan">newman.util.</span>prettyms
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prettyms = function (ms) {
    return (ms &#x3c; 1998) ? `${parseInt(ms, 10)}ms` : prettyms(ms || 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
